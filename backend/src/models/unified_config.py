"""
Unified Job Configuration Models
Feature: 001-edit-api-simplification

This module defines the simplified unified configuration model that replaces
the complex three-object system (job, input, output) with a single flat structure.
"""

from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Literal
from datetime import datetime
import re


class RenditionConfig(BaseModel):
    """
    Configuration for a single ABR (Adaptive Bitrate) rendition.

    Multiple renditions create an adaptive streaming experience where
    clients can switch between quality levels based on bandwidth.
    """
    name: str = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Rendition name (e.g., '1080p', '720p'). Must be unique within ladder."
    )

    videoBitrate: str = Field(
        ...,
        description="Video bitrate for this rendition (e.g., '5M', '2500k')"
    )

    videoResolution: str = Field(
        ...,
        pattern=r'^\d+x\d+$',
        description="Resolution for this rendition (e.g., '1920x1080')"
    )

    videoFrameRate: Optional[int] = Field(
        None,
        ge=1,
        le=120,
        description="Optional frame rate override for this rendition"
    )

    audioCodec: Optional[Literal['aac', 'mp3', 'opus', 'vorbis']] = Field(
        None,
        description="Optional audio codec override"
    )

    audioBitrate: Optional[str] = Field(
        None,
        description="Optional audio bitrate override (e.g., '128k')"
    )

    @field_validator('videoBitrate', 'audioBitrate')
    @classmethod
    def validate_bitrate_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate bitrate format matches pattern"""
        if v is None:
            return v
        # Allow decimals: 1.5M, 2.5M, etc.
        if not re.match(r'^\d+(\.\d+)?[KMG]$', v, re.IGNORECASE):
            raise ValueError(
                f"Invalid bitrate format: {v}. Use format like '5M', '1.5M', '2500k', or '128K'"
            )
        return v

    @field_validator('videoResolution')
    @classmethod
    def validate_resolution_format(cls, v: str) -> str:
        """Validate resolution format matches WIDTHxHEIGHT pattern"""
        if not re.match(r'^\d+x\d+$', v):
            raise ValueError(
                f"Invalid resolution format: {v}. Use format like '1920x1080'"
            )
        return v


class UnifiedJobConfig(BaseModel):
    """
    Unified job configuration model that consolidates all job, input, and output settings.

    This replaces the three-object system with a single flat structure that can be:
    - Directly bound to frontend forms
    - Stored as JSON in the database cache
    - Used for simplified API operations

    Feature: 001-edit-api-simplification
    """

    # ============================================================================
    # Job Metadata (read-only fields generated by system)
    # ============================================================================

    id: Optional[str] = Field(
        None,
        description="Job identifier (UUID, generated by system, read-only)"
    )

    jobName: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Human-readable job name"
    )

    status: Optional[Literal['pending', 'running', 'completed', 'failed', 'stopped']] = Field(
        None,
        description="Current job status (read-only, managed by job control)"
    )

    createdAt: Optional[datetime] = Field(
        None,
        description="Job creation timestamp (read-only)"
    )

    updatedAt: Optional[datetime] = Field(
        None,
        description="Last update timestamp (read-only)"
    )

    # ============================================================================
    # Input Configuration
    # ============================================================================

    inputFile: str = Field(
        ...,
        min_length=1,
        description="Path to input video file"
    )

    loopInput: bool = Field(
        default=False,
        description="Whether to loop the input continuously"
    )

    startTime: Optional[str] = Field(
        None,
        pattern=r'^\d{2}:\d{2}:\d{2}$',
        description="Start time offset in HH:MM:SS format"
    )

    duration: Optional[str] = Field(
        None,
        pattern=r'^\d{2}:\d{2}:\d{2}$',
        description="Duration to encode in HH:MM:SS format"
    )

    # ============================================================================
    # Video Encoding Settings
    # ============================================================================

    videoCodec: str = Field(
        ...,
        description="Video codec to use"
    )

    videoBitrate: Optional[str] = Field(
        None,
        description="Video bitrate (e.g., '5M', '2500k'). If not specified, FFmpeg will use default quality settings"
    )

    videoResolution: Optional[str] = Field(
        None,
        pattern=r'^\d+x\d+$',
        description="Video resolution in WIDTHxHEIGHT format (e.g., '1920x1080')"
    )

    videoFrameRate: Optional[int] = Field(
        None,
        ge=1,
        le=120,
        description="Frame rate in fps (e.g., 30, 60)"
    )

    videoPreset: Optional[Literal['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow']] = Field(
        'medium',
        description="Encoding speed/quality preset"
    )

    videoProfile: Optional[Literal['baseline', 'main', 'high', 'high10', 'high422', 'high444']] = Field(
        None,
        description="Encoding profile for H.264/H.265"
    )

    videoLevel: Optional[str] = Field(
        None,
        description="Encoding level (e.g., '4.1')"
    )

    videoGOP: Optional[int] = Field(
        None,
        ge=1,
        le=1000,
        description="GOP (Group of Pictures) size - keyframe interval in frames (e.g., 60 for 2 seconds at 30fps)"
    )

    # ============================================================================
    # Hardware Acceleration
    # ============================================================================

    hardwareAccel: Optional[Literal['none', 'nvenc', 'qsv', 'vaapi']] = Field(
        None,
        description="Hardware acceleration type"
    )

    hardwareDevice: Optional[str] = Field(
        None,
        description="Device index for hardware encoder (e.g., '0')"
    )

    # ============================================================================
    # Audio Encoding Settings
    # ============================================================================

    audioCodec: str = Field(
        ...,
        description="Audio codec to use"
    )

    audioBitrate: str = Field(
        ...,
        description="Audio bitrate (e.g., '128k', '192k')"
    )

    audioSampleRate: Optional[int] = Field(
        48000,
        description="Audio sample rate in Hz (e.g., 48000, 44100)"
    )

    audioChannels: Optional[int] = Field(
        2,
        ge=1,
        le=8,
        description="Number of audio channels (1=mono, 2=stereo, 6=5.1, 8=7.1)"
    )

    audioVolume: Optional[int] = Field(
        None,
        ge=0,
        le=100,
        description="Audio volume percentage (0-100, where 100 is original volume)"
    )

    # ============================================================================
    # Track Selection (Stream Mapping)
    # ============================================================================

    streamMaps: Optional[List[dict]] = Field(
        None,
        description="Stream mapping configuration for selecting specific video/audio tracks from multi-track input. Format: [{'input_stream': '0:v:0', 'output_label': 'v'}, {'input_stream': '0:a:1', 'output_label': 'a'}]"
    )

    # ============================================================================
    # Output Configuration
    # ============================================================================

    outputFormat: str = Field(
        ...,
        description="Output container format (e.g., 'hls', 'dash', 'mp4', 'webm', 'rtmp')"
    )

    outputDir: Optional[str] = Field(
        None,
        description="Output directory path (required for hls/dash/mp4/webm, not needed for rtmp/udp)"
    )

    outputUrl: Optional[str] = Field(
        None,
        description="Output URL for streaming protocols (rtmp://, udp://, srt://)"
    )

    # ============================================================================
    # HLS-specific Settings
    # ============================================================================

    hlsSegmentDuration: Optional[int] = Field(
        6,
        ge=1,
        le=60,
        description="HLS segment duration in seconds"
    )

    hlsPlaylistType: Optional[Literal['vod', 'event']] = Field(
        'vod',
        description="HLS playlist type"
    )

    hlsPlaylistSize: Optional[int] = Field(
        5,
        ge=1,
        le=100,
        description="HLS playlist size (number of segments to keep)"
    )

    hlsSegmentType: Optional[Literal['mpegts', 'fmp4']] = Field(
        'mpegts',
        description="HLS segment type (mpegts or fmp4)"
    )

    hlsSegmentFilename: Optional[str] = Field(
        'segment_%03d.ts',
        description="HLS segment filename pattern (e.g., 'segment_%03d.ts')"
    )

    # ============================================================================
    # ABR (Adaptive Bitrate) Configuration
    # ============================================================================

    abrEnabled: bool = Field(
        default=False,
        description="Whether adaptive bitrate streaming is enabled"
    )

    abrLadder: Optional[List[RenditionConfig]] = Field(
        None,
        description="Array of rendition configurations (required if abrEnabled is true)"
    )

    # ============================================================================
    # Advanced Options
    # ============================================================================

    customFFmpegArgs: Optional[str] = Field(
        None,
        description="Additional custom FFmpeg arguments"
    )

    maxRetries: Optional[int] = Field(
        3,
        ge=0,
        le=10,
        description="Maximum retry attempts on failure"
    )

    # ============================================================================
    # Generated Fields (read-only)
    # ============================================================================

    ffmpegCommand: Optional[str] = Field(
        None,
        description="Generated FFmpeg command (read-only, computed by backend)"
    )

    # ============================================================================
    # Validators
    # ============================================================================

    @field_validator('videoBitrate', 'audioBitrate')
    @classmethod
    def validate_bitrate_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate bitrate format"""
        if v is None:
            return v
        if not re.match(r'^\d+(\.\d+)?[KMG]$', v, re.IGNORECASE):
            raise ValueError(
                f"Invalid bitrate format: {v}. Use format like '5M', '1.5M', '2500k', or '128K'"
            )
        return v

    @field_validator('videoResolution')
    @classmethod
    def validate_resolution_format(cls, v: Optional[str]) -> Optional[str]:
        """Validate resolution format"""
        if v is None:
            return v
        if not re.match(r'^\d+x\d+$', v):
            raise ValueError(
                f"Invalid resolution format: {v}. Use format like '1920x1080'"
            )
        return v

    @field_validator('abrLadder')
    @classmethod
    def validate_abr_ladder(cls, v: Optional[List[RenditionConfig]], info) -> Optional[List[RenditionConfig]]:
        """Validate ABR ladder when ABR is enabled"""
        # Access abrEnabled from the values being validated
        # Note: In Pydantic v2, we need to check if this validator runs after abrEnabled
        # For now, we'll do this validation in the validator service
        return v

    def model_post_init(self, __context):
        """Post-initialization validation"""
        # Validate ABR configuration
        if self.abrEnabled and (not self.abrLadder or len(self.abrLadder) == 0):
            raise ValueError("ABR ladder is required when abrEnabled is true")

        # Validate unique rendition names if ABR is enabled
        if self.abrLadder:
            names = [r.name for r in self.abrLadder]
            if len(names) != len(set(names)):
                raise ValueError("Rendition names must be unique within ABR ladder")

    model_config = {
        "json_schema_extra": {
            "example": {
                "jobName": "My Encoding Job",
                "inputFile": "/input/video.mp4",
                "loopInput": False,
                "videoCodec": "h264",
                "videoBitrate": "5M",
                "videoResolution": "1920x1080",
                "videoFrameRate": 30,
                "videoPreset": "medium",
                "hardwareAccel": "nvenc",
                "audioCodec": "aac",
                "audioBitrate": "128k",
                "audioSampleRate": 48000,
                "audioChannels": 2,
                "outputFormat": "hls",
                "outputDir": "/output/hls/job-123",
                "hlsSegmentDuration": 6,
                "hlsPlaylistType": "vod",
                "abrEnabled": True,
                "abrLadder": [
                    {
                        "name": "1080p",
                        "videoBitrate": "5M",
                        "videoResolution": "1920x1080"
                    },
                    {
                        "name": "720p",
                        "videoBitrate": "3M",
                        "videoResolution": "1280x720"
                    },
                    {
                        "name": "480p",
                        "videoBitrate": "1500k",
                        "videoResolution": "854x480"
                    }
                ],
                "maxRetries": 3
            }
        }
    }


# Default configuration values
DEFAULT_UNIFIED_CONFIG = {
    "loopInput": False,
    "videoPreset": "medium",
    "audioSampleRate": 48000,
    "audioChannels": 2,
    "hlsSegmentDuration": 6,
    "hlsPlaylistType": "vod",
    "abrEnabled": False,
    "maxRetries": 3
}
